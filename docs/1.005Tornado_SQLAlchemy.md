# 5 SQLAlchemy
## 5.1 ORM
**ORM全称 Object Relational Mapping对象关系映射**

通过 ORM 可以不用关心后台是使用的哪种数据库，只需要按照 ORM 所提供的语法规则去书写相应的代码， ORM 就会自动的转换成对应对应数据库的 SQL 语句

## 5.2 SQLAIchemy连接数据库
### 5.2.1 安装
#### 5.2.1.1 安装mysql
Mysql安装教程连接:
#### 5.2.1.2 安装python包`pymysql`、`sqlalchemy`
1. pymysql安装:`pip install pymysql`
2. sqlalchemy安装:`pip install sqlalchemy`

#### 5.2.2 导入create_engine模块
db.py代码
```
from sqlalchemy import create_engine
```

#### 5.2.3  数据库连接配置

```
HOSTNAME = '127.0.0.1'
PORT = '3306'
DATABASE = 'mysql'
USERNAME = 'leva'
PASSWORD = 'leva123'
```

#### 5.2.4 数据库连接URL
```
# 第一种数据库连接
DB_url = 'mysql+pymysql://%s:%s@%s:%s/%s?charset=utf8' %(
    USERNAME,
    PASSWORD,
    HOSTNAME,
    PORT,
    DATABASE
)

# 第二种数据库连接 
DB_url = 'mysql+pymysql://{}:{}@{}:{}/{}?charset=utf8'.format(
    USERNAME,
    PASSWORD,
    HOSTNAME,
    PORT,
    DATABASE
)
```

#### 5.2.5 数据库连接
```
engine = create_engine(DB_url)
```

#### 5.2.6 测试数据库
```
if __name__== '__main__':
    connection = engine.connect()
    result = connection.execute('select 1')
    print(result)
```
#### 5.2.7 创建一个基类
```
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base(engine)
```
1. 对象关系型映射，数据库中的表与python中的类相对应，创建的类必须继承自 sqlalchemy 中的基类。
2. 使用 declarative 方法定义的映射类依据一个基类，这个基类是维系类和数据表关系的目录。
3. 应用通常只需要有一个 Base 的实例。我们通过 declarative_base() 功能创建一个基类。
```
from sqlalchemy import create_engine #create_engine模块
from sqlalchemy.ext.declarative import declarative_base #导入一个基类模块

HOSTNAME = '127.0.0.1'
PORT = '3306'
DATABASE = 'mydb'
USERNAME = 'leva'
PASSWORD = 'leva123'

DB_url = 'mysql+pymysql://{}:{}@{}:{}/{}?charset=utf8'.format(
    USERNAME,
    PASSWORD,
    HOSTNAME,
    PORT,
    DATABASE
)

engine = create_engine(DB_url)

Base = declarative_base(engine) # 这个Base类就是基类
```
## 5.3 Module
**通过SQLALchemy提供的语法来声明表**
1. __ tablename__ : 数据库中表名
2. Column: 用来创建表中的字段的一个方法
3. Integer: 整型，映射到数据库中的类型
4. String: 字符类型，映射到数据库中的类型，使用时，需要提供一个字符长度
5. DateTime:  时间类型

### 5.3.1 创建数据库模型
```
from connect import Base
from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
```

1. 再次强调，我们用类来表示数据库里面的表！！！
2. 这些表的类都继承于我们的Base基类。
3. 在类里面我们定义一些属性，这个属性通过映射，就对应表里面的字段
user_modules.py代码
```
from connect import Base
from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime

class User(Base):
    """建立数据库模型对应User表"""
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(20))
    password = Column(String(20))
    creat_time = Column(DateTime,default=datetime.now())
    _locked = Column(Boolean,default=False,nullable=False)

if __name__ == "__main__":
    Base.metadata.create_all() #执行此代码，就会把创建好的 Module 映射到数据库中
```

## 5.4 增删改查

### 5.4.1 创建会话
在对表数据进行增删改查之前，先需要建立会话，建立会话之后才能进行操作，就类似于文件要打开之后才能对文件内容操作
connect.py添加如下代码
```
from sqlalchemy.orm import sessionmaker #导入sessionmaker

Session = sessionmaker(engine) #创建一个session会话
session = Session() #实例化session
```
### 5.4.2 简单增删改查

#### 5.4.2.1 添加单条数据
```
from connect import session
from user_modules import User

def add_user():
    """添加数据"""
    """添加单条数据方法"""
    person = User(username='Leva',password='123')
    session.add(person)
    session.commit() #提交事务

if  __name__ == "__main__":
    add_user()
```

#### 5.4.2.2 添加多条数据
```
from connect import session
from user_modules import User

def add_user():
    """添加数据"""
    """添加多条数据方法"""
        session.add_all([
        User(username='zlk',password='123'),
        User(username='rave',password='123'),
    ])
    session.commit() #提交事务

if  __name__ == "__main__":
    add_user()
```

#### 5.4.2.3 数据模型显示格式
test_user_modules.py代码
```
from connect import Base
from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime

class User(Base):
    """建立数据库模型对应User表"""
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(20))
    password = Column(String(20))
    creat_time = Column(DateTime,default=datetime.now())
    _locked = Column(Boolean,default=False,nullable=False)

    def __repr__(self): #数据模型显示样式设置
        return"""
            <User(id=%s),username=%s,password=%s,creat_time=%s,_locked=%s>
        """ %(
            self.id,
            self.username,
            self.password,
            self.creat_time,
            self._locked,
        )

```

#### 5.4.2.4 查询第一条数据
```
from connect import session
from user_modules import User

def search_user():
    """查询数据"""
    rows = session.query(User).first() #查询所有数据库
    print(rows)

if  __name__ == "__main__":
    search_user()
```

#### 5.4.2.5 查询所有数据
```
from connect import session
from user_modules import User

def search_user():
    """查询数据"""
    rows = session.query(User).all() #查询所有数据库
    print(rows)

if  __name__ == "__main__":
    search_user()
```

#### 5.4.2.6 更新数据
```
from connect import session
from user_modules import User

def update_user():
    #查询出用户名为Leva，然后update把数据的密码进行更新。
    session.query(User).filter(User.username =="Leva").update({User.password:1})
    session.commit()

if  __name__ == "__main__":
    update_user()
```

#### 5.4.2.7 删除数据
```
from connect import session
from user_modules import User

def delete_user():
    rows = session.query(User).filter(User.username=='Leva')[0]
    session.delete(rows)
    session.commit()

if  __name__ == "__main__":
    delete_user()
```

## 5.5 查询结果

### 5.5.1 
```
from connect import session
from user_modules import User
```

### 5.5.2 query返回对象
使用 SQLAlchemy 时，如果想要查看最终在数据库中执行的 sql ，可以通过以下方式来查看
```
rs = session.query(User).filter(User.username=='zlk')
print(rs,type(rs))
```
根据返回结果来看， rs  是一个 Query 对象，打印出来可以看到转化的 SQL

#### 5.5.2.1 all
all 是返回所有符合条件的数据
```
rs = session.query(User).filter(User.username=='zlk').all()
```
这里，在 query 中查询对象的某个属性值 ( 对应为查询表中某个字段的值 )，返回的结果不再是一个 Query 对象，而是一个列表
```
session.query(User.username).filter(User.username=='zlk').all()
```

#### 5.5.2.2 first
first 是返回所有符合条件数据的第一条数据
```
rs = session.query(User).filter(User.username=='zlk').first()
```
同理，但是 first 返回结果是一个元组
```
session.query(User.username).filter(User.username=='zlk').first()
```

#### 5.5.2.3 [0]
[0] 和 first 类似，但是如果没有符合条件的数据则会报错
```
rs = session.query(User).filter(User.username=='zlk')[0]
```
[0] 和 first 类似，但是如果没有符合条件的数据则会报错
```
session.query(User.username).filter(User.username=='zlk')[0]
```
#### 5.5.2.4 取值方式
getattr(rs[0], 'username'),  rs[0].username 这两种方式可以取到具体的数据值
```
rs = session.query(User).filter(User.username=='zlk').all()
```

### 5.5.3 查询结果总结
1. 《返回对象》必须掌握：不同查询方式，返回对象的区别。如果是整表查询则返回Module的一个实例；如果是查询某个属性，返回的则是具体的数据
2. 《返回结果取值》必须掌握：不同的返回结果，取值方式也会有所区别，如果是 Module 实例，需要通过属性访问的方式取值，同时也要注意 all 和 first 返回的结果的区别

## 5.6 条件查询
在实际的工作中，查询的时候会有很多的要求，通过不同的条件筛选出精准的数据，那在SQLAlchemy中该如何进行条件查询呢？

### 5.6.1 过滤函数

#### 5.6.1.1 filter
filter 是一个**过滤函数**，过滤条件都可以书写在此函数中，不同的条件之间用 **逗号** 分隔
```
session.query(User).filter(User.username == 'zlk').all()
```

#### 5.6.1.2 filter_by
filter_by 也是一个过滤函数，但是功能要弱一些
```
session.query(User).filter_by(username = 'zlk').all()
```

#### 5.6.1.3 filter 和 filter_by 的区别
**二者都是 过滤函数，但是使用有如下差别：**
1. `filter` 中需要添加 类对象，filter_by不需要
2. `filter_by` 中只能添加等于的条件，不能添加 不等于、大于小于等条件，filter没有这个限制

### 5.6.2 模糊查询

#### 5.6.2.1 like 和 notlike
1. `like` 是模糊查询，和数据库中的 like 用法一样
2. `notlike` 和 `like` 作用相反
```
session.query(User.id).filter(User.username.like('zlk')).all()

session.query(User.id).filter(User.username.notlike('zlk')).all()
```

#### 5.6.2.3 in_ 和 notin_
in_  和 notin_  是范围查找
```
session.query(User.id).filter(User.username.in_(['zlk','tuple'])).all()

session.query(User.id).filter(User.username.notin_(['zlk','tuple'])).all()
```

#### 5.6.2.4 is_ 和 isnot
is_  和 isnot  精确查找  
```
session.query(User.id).filter(User.username.is_(None)).all()

session.query(User.id).filter(User.username.isnot(None))).all()

# 判断为空还可以使用：
session.query(User.id).filter(User.username == None).all()
```


### 5.6.3 查询结果数

#### 5.6.3.1 all
先用 all 查看所有的数据
```
session.query(User.username).filter(User.username != 'zlk').all()
```

#### 5.6.3.2 limit
limit  查看前两条数据
```
session.query(User.username).filter(User.username != 'zlk').limit(2).all()
```

#### 5.6.3.3 offset
offset  偏移一条记录
```
session.query(User.username).filter(User.username != 'zlk').offset(1).all()
```

#### 5.6.3.4 slice
slice 对查询出来的数据进行切片取值
```
session.query(User.username).filter(User.username != 'zlk').slice(1,3).all()
```

#### 5.6.3.5 one
one  查询一条数据，如果存在多条则报错   
```
session.query(User.username).filter(User.username != 'zlk').one()
```


### 5.6.4 排序
```
from sqlalchemy import desc
```

#### 5.6.4.1 order_by
order_by 对查询出来的结果进行排序，默认是顺序
```
session.query(User.username).filter(User.username != 'zlk').order_by(User.id).all()
```

#### 5.6.4.2 desc
desc 是倒序排序
```
session.query(User.username).filter(User.username != 'zlk').order_by(desc(User.username)).all()
```

#### 5.6.4.3 order_by 和 limit
order_by  和 limit 一起使用的时候，可以通过如下方式
```
session.query(User.username).filter(User.username != 'zlk').order_by(User.username)limit(3).all()
```

### 5.6.5 函数
导入 func，extract
```
from sqlalchemy import func, extract
```

#### 5.6.5.1 func.count
使用函数时，需要导入 func， group_by 和 order_by 一样，是可以直接使用的，不需要导入 
```
session.query(User.password,func.count(User.id)).group_by(User.password).all()
```

#### 5.6.5.1 having
having 也可以直接使用，使用方法也和 SQL 中使用类似
```
session.query(User.password,func.count(User.id)).group_by(User.password).having(func.count(User.id)>1).all()
```

### 5.6.6 聚合函数

#### 5.6.6.1 func.sum
sum求和
```
session.query(User.password, func.sum(User.id)).group_by(User.password).all()
```

#### 5.6.6.2 func.max
max 求最大值
```
session.query(User.password,func.max(User.id)).group_by(User.password).all()
```

#### 5.6.6.3 func.min
min 求最大值
```
session.query(User.password,func.min(User.id)).group_by(User.password).all()
```

#### 5.6.6.4 extract 函数
`extract` 提取对象中的数据，这里提取分钟，并把提取出来的结果用 `label`命名别名，之后就可以使用 `group_by` 来分组
```
session.query(extract('minute',User.creatime).labe('minute'),func.count(User.id)).group_by('minute').all()
```
count 里面同样可以使用 * 

这里只是给出一个演示实例，如果在今后需要使用其他的函数，导入即可
```
session.query(extract('day',creatime).label('day'),func.count('*')).group_by('day').all()
```

### 5.6.7 选择条件

#### 5.6.7.1 or_
or_  是或者的意思，和数据库中的 or 一样
```
from sqlalchemy import or_

session.query(User.username).filter(or_(User.username.isnot(None),User.password == '123')).all()
```

### 5.6.8 查询总结
1. 《过滤函数》必须掌握:两个过滤函数的用法和区别  
2. 《函数》必须掌握:使用函数的方法
3. 《模糊查询》必须掌握:常见的模糊查询方法
4. 《排序》必须掌握:排序方法和分组等方法

## 5.7 多表查询
## 5.8 原生sql查询
## 5.9 一对一表关系
## 5.10 多对多表关系
## 5.11 包管理
## 5.12 简单的登录